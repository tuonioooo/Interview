# Redis—01

参考地址：

Redis详细教程：[https://tuonioooo.gitbooks.io/high-concurrent-cache/content/redis.html](https://tuonioooo.gitbooks.io/high-concurrent-cache/content/redis.html)

**1**.**Redis 是什么？都有哪些使用场景？**

Redis 是一个使用 C 语言开发的高速缓存数据库。

Redis 使用场景：

* 记录帖子点赞数、点击数、评论数；
* 缓存近期热帖；
* 缓存文章详情信息；
* 记录用户会话信息。

**2. Redis 有哪些功能？**

* 数据缓存功能
* 分布式锁的功能
* 支持数据持久化
* 支持事务
* 支持消息队列

**3. Redis 和 memcache 有什么区别？**

* 存储方式不同：

  memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。

* 数据支持类型：

  memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。

* 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，

  Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。

* value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。
* redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多.

如图所示：

![](../../.gitbook/assets/2528523275-5ad8abd940cd7_articlex.jpg)

**4. Redis 为什么是单线程的？**

因为cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

关于Redis 的性能，官方网站也有，普通笔记本轻松处理Redis能读的速度是110000次/s,写的速度是81000次/s的请求。

而且单线程并不代表就慢nginx 和 nodejs 也都是高性能单线程的代表。

**5. 什么是缓存穿透？怎么解决？**

缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决方案：

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。

2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。

#### **6. Redis 支持的数据类型有哪些？**以及使用场景分析？

Redis 支持的数据类型：string（字符串）、list（列表）、hash（散列表）、set（集合）、\(Sorted set\)zset（有序集合）。

**String** 

> 常用命令:set、zget、zdecr、zincr、mget 等。

String数据结构是简单的key-value类型，value其实不仅可以是String, 也可以是数字。 常规key-value 缓存应用；常规计数：微博数，粉丝数等。

 **Hash**

> 常用命令：hget、zhset、zhget、all 等。

hash是一个string类型的field和 value的映射表，hash特别适合用于存储对象，后续操作的时候，你 可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以hash数据结构来存储用户信息，商品信 息等等。比如下面我就用hash类型存放了我本人的一些信息：

```text
key=Javalise r293847 value={ " id " : 1, "name": "S n ailC lim b", “ age〃： 22, "lo c a tio n ": "Wuhan, Hubei"}
```

 **List**

> 常用命令:lpush、zrpush、lpop、rpop、lrange等

list就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表, 粉丝列表，消息列表等功能都可以用Redis的 list结构来实现。 Redis list的实现为一个双向链表、即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内 存开销。 另外可以通过lrange命令，就是从某个元素开始读取多少个元素，可以基于list实现分页查询，这个很 棒的一个功能，基于redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一 页的往下走），性能高。

 **Set**

> 常用命令：sadd,spop,smembers,sunion 等

set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。 当你需要存储一个列表数据，又不希望出现重复数据时.set是一个很好的选择，并且set提供了判断某 个成员是否在一个set集合内白懂要接口，这个也是list所不能提供的。可以基于set轻易实现交集、并集、差集的操作。 比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。 Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程, 具体命令如下**。**

```text
sinterstore keyl key2 key3 将交集存在keyl内
```

 **Sorted Set**

> 常用命令：zadd,zrange,zrem,zcard 等

和set相比，sorted set增加了一个权重参数score,使得集合中的元素能够按score进行有序排列。 举例：在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解 为按消息维度的消息排行榜）等信息，适合使用Redis中的Sorted Set结构进行存储

**7. Redis 支持的 Java 客户端都有哪些？**

支持的Java 客户端有 Redisson、jedis、lettuce 等。

**8. jedis 和 Redisson 有哪些区别？**

* jedis：提供了比较全面的 Redis 命令的支持。
* Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。

**9. 怎么保证缓存和数据库数据的一致性？**

* 合理设置缓存的过期时间。
* 新增、更改、删除数据库操作时同步更新

  Redis，可以使用事物机制来保证数据的一致性。

**10. Redis 持久化有几种方式？**

Redis 的持久化有两种方式，或者说有两种策略：

* RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。
* AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

> 注意：
>
> **RDB**：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案。速度快但是服务器断电的时候会丢失部分数据
>
> **AOF**：append only file。把所有对redis数据库操作的命令，增删改操作的命令。保存到文件中。数据库恢复时把所有的命令执行一遍即可。两种持久化方案同时开启使用AOF文件来恢复数据库.能保证数据的完整性,但是速度慢。
>
> 两者如何选择?
>
> 1. 如果redis仅仅是用来做为缓存服务器的话，我们可以不使用任何的持久化。
> 2. 一般情况下我们会将两种持久化的方式都开启。redis优先加载AOF文件来回复数据。RDB的好处是快速。
> 3. 在主从节点中，RDB作为我们的备份数据，只在salve\(从节点\)上启动，同步时间可以设置的长一点，只留\(save 900 1\)这条规则就可以了。
> 4. 开启AOF的情况下，主从同步是时候必然会带来IO的性能影响，此时我们可以调大auto-aof-rewrite-min-size的值，比如5GB。来减少IO的频率
> 5. 不开启AOF的情况下，可以节省IO的性能影响，这是主从间通过RDB持久化同步，但如果主从都挂掉，影响较大~

**11. Redis 怎么实现分布式锁？**

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用setnx\(set if not exists\)指令，只允许被一个程序占有，使用完调用 del 释放锁。

**12. Redis 分布式锁有什么缺陷？**

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

**13. Redis 如何做内存优化？**

尽量使用Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。

**14. Redis 淘汰策略有哪些？**

* volatile-lru：从已设置过期时间的数据集（server. db\[i\]. expires）中挑选最近最少使用的数据淘汰。
* volatile-ttl：从已设置过期时间的数据集（server. db\[i\]. expires）中挑选将要过期的数据淘汰。
* volatile-random：从已设置过期时间的数据集（server. db\[i\]. expires）中任意选择数据淘汰。
* allkeys-lru：从数据集（server. db\[i\]. dict）中挑选最近最少使用的数据淘汰。
* allkeys-random：从数据集（server. db\[i\]. dict）中任意选择数据淘汰。
* no-enviction（驱逐）：禁止驱逐数据。

**15. Redis 常见的性能问题有哪些？该如何解决？**

* 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
* Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。
* 尽量避免在压力很大的主库上增加从库
* 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

**16.Redis如何进行快照存储（如何进行RDB存储）？**

快照，顾名思义可以理解为拍照一样，把整个内存数据映射到硬盘中，保存一份到硬盘，因此恢复数据起来比较快，把数据映射回去即可，不像AOF，一条条的执行操作命令。产生快照的过程：

1 .用户在配置文件了配置了类似这样的命令

```text
save 900 1 // 900秒内,有1条写入,则产生快照
save 300 1000 // 如果300秒内有1000次写入,则产生快照
save 60 10000 // 如果60秒内有10000次写入,则产生快照
```

\(这3个选项都屏蔽,则rdb禁用\)

2.执行bgsave命令\(此时redis会fork一个子进程,子进程负责生成硬盘文件,父进程负责继续接受命令\).

或执行save命令\(和bgsave命令不同,发送save命令后,到系统创建快照完成之前系统不会再接收新的命令,换句话说save命令会阻塞后面的命令,而bgsave不会\)

3.用户发送shutdown,系统会先执行save命令阻塞客户端,然后关闭服务器  
4.当有主从架构时,从服务器向主服务器发送sync命令来执行复制操作时,当时只要主服务器没有进行bgsave操作,那么主服务器就会执行bgsave操作。

**17.Dump快照的机制**

1\). Redis先fork子进程。

2\). 子进程将快照数据写入到临时RDB文件中。

3\). 当子进程完成数据写入操作后，再用临时文件替换老的文件。

**18**.**Redis 集群方案什么情况下会导致整个集群不可用？**

1\).有 A，B，C 三个节点的集群,在没有复制模型的情况下\(没有slave情下况\),如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。

2\).如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态

**19、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？**

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略.

淘汰策略：**参考上面的14.**

**20.说说 Redis 哈希槽的概念？**

Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

**21.Redis 集群的主从复制模型是怎样的？**

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.

**22.Redis 集群会有写操作丢失吗？为什么？**

Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

**23.Redis 集群之间是如何复制的？**

异步复制

**24.Redis 集群最大节点个数是多少？**

16384 个

**25.Redis 集群如何选择数据库？**

Redis 集群目前无法做数据库选择，默认在 0 数据库。

**26.Redis 中的管道有什么用？**

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。

**27.怎么理解 Redis 事务？**

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

**28.Redis与MySQL中事务的区别**

事务命令

mysql：

```text
begin      #显式地开启一个事务
commit      #提交事务，对数据库进行的所有写操作变为永久性的
rollback  #结束用户的事务，并撤销正在进行的所有未提交的写操作
```

redis支持简单的事务：

```text
multi        #标记事务的开始
exec        #执行事务的commands队列
discard        #结束事务，并清除commands队列
```

rollback和discard的区别：

如果已经成功执行了2条语句，第3条语句出错。roolback后撤销前面2条语句的照成的影响；discard只是结束本次事务，前面2条语句造成的影响仍然存在。

在multi后面的语句出错可能有两种情况：

1、语法就有问题。\(这种exec时报错，所有语句都不执行\)

2、语法本身没有错，但使用对象有问题。比如zadd命令操作link对象，exec之后回执行正确的语句并跳过不适当的语句。

**29.Redis key 的过期时间和永久有效分别怎么设置**

EXPIRE 和 PERSIST 命令

**30.什么是缓存雪崩？解决方案?**

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

解决方案：

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期

3：不同的 key，设置不同的过期时间（每个key后面加一个随时间戳），让缓存失效的时间点尽量均匀

**31.什么**是**缓存击穿？**

一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。

解决方案：

在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

**32**.**使用过 Redis 做异步队列么，你是怎么用的？有什么缺点？**

般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep一会再重试。

方式一：生产者消费者模式  
使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。  
或者，不用sleep，直接用blpop指令，在没有消息的时候，它会阻塞住直到消息到来。

方式二：发布订阅者模式  
使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

缺点**：**在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。

\*\*\*\*

\*\*\*\*













