参考地址：

Redis详细教程：[https://tuonioooo.gitbooks.io/high-concurrent-cache/content/redis.html](https://tuonioooo.gitbooks.io/high-concurrent-cache/content/redis.html)

Redis相关面试题：

[https://cloud.tencent.com/developer/article/1409260](https://cloud.tencent.com/developer/article/1409260)

**1**.**Redis 是什么？都有哪些使用场景？**

Redis 是一个使用 C 语言开发的高速缓存数据库。

Redis 使用场景：

* 记录帖子点赞数、点击数、评论数；
* 缓存近期热帖；
* 缓存文章详情信息；
* 记录用户会话信息。

**2. Redis 有哪些功能？**

* 数据缓存功能
* 分布式锁的功能
* 支持数据持久化
* 支持事务
* 支持消息队列

**3. Redis 和 memcache 有什么区别？**

* 存储方式不同：
  memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。
* 数据支持类型：
  memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。
* 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，
  Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
* value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。
* redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多.

如图所示：

![](/assets/2528523275-5ad8abd940cd7_articlex.jpg)

**4. Redis 为什么是单线程的？**

因为cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

关于Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。

而且单线程并不代表就慢nginx 和 nodejs 也都是高性能单线程的代表。

**5. 什么是缓存穿透？怎么解决？**

缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决方案：

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。

2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。

**6. Redis 支持的数据类型有哪些？**

Redis 支持的数据类型：string（字符串）、list（列表）、hash（散列表）、set（集合）、\(Sorted set\)zset（有序集合）。

**7. Redis 支持的 Java 客户端都有哪些？**

支持的Java 客户端有 Redisson、jedis、lettuce 等。

**8. jedis 和 Redisson 有哪些区别？**

* jedis：提供了比较全面的 Redis 命令的支持。
* Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。

**9. 怎么保证缓存和数据库数据的一致性？**

* 合理设置缓存的过期时间。
* 新增、更改、删除数据库操作时同步更新
  Redis，可以使用事物机制来保证数据的一致性。

**10. Redis 持久化有几种方式？**

Redis 的持久化有两种方式，或者说有两种策略：

* RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。
* AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

> 注意：
>
> **RDB**：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案。速度快但是服务器断电的时候会丢失部分数据
>
> **AOF**：append only file。把所有对redis数据库操作的命令，增删改操作的命令。保存到文件中。数据库恢复时把所有的命令执行一遍即可。两种持久化方案同时开启使用AOF文件来恢复数据库.能保证数据的完整性,但是速度慢。
>
> 两者如何选择?
>
> 1. 如果redis仅仅是用来做为缓存服务器的话，我们可以不使用任何的持久化。
> 2. 一般情况下我们会将两种持久化的方式都开启。redis优先加载AOF文件来回复数据。RDB的好处是快速。
> 3. 在主从节点中，RDB作为我们的备份数据，只在salve\(从节点\)上启动，同步时间可以设置的长一点，只留\(save 900 1\)这条规则就可以了。
> 4. 开启AOF的情况下，主从同步是时候必然会带来IO的性能影响，此时我们可以调大auto-aof-rewrite-min-size的值，比如5GB。来减少IO的频率
> 5. 不开启AOF的情况下，可以节省IO的性能影响，这是主从间通过RDB持久化同步，但如果主从都挂掉，影响较大~

**11. Redis 怎么实现分布式锁？**

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用setnx\(set if not exists\)指令，只允许被一个程序占有，使用完调用 del 释放锁。

**12. Redis 分布式锁有什么缺陷？**

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

**13. Redis 如何做内存优化？**

尽量使用Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。

**14. Redis 淘汰策略有哪些？**

* volatile-lru：从已设置过期时间的数据集（server. db\[i\]. expires）中挑选最近最少使用的数据淘汰。
* volatile-ttl：从已设置过期时间的数据集（server. db\[i\]. expires）中挑选将要过期的数据淘汰。
* volatile-random：从已设置过期时间的数据集（server. db\[i\]. expires）中任意选择数据淘汰。
* allkeys-lru：从数据集（server. db\[i\]. dict）中挑选最近最少使用的数据淘汰。
* allkeys-random：从数据集（server. db\[i\]. dict）中任意选择数据淘汰。
* no-enviction（驱逐）：禁止驱逐数据。

**15. Redis 常见的性能问题有哪些？该如何解决？**

* 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
* Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。
* 尽量避免在压力很大的主库上增加从库
* 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

**16.Redis如何进行快照存储（如何进行RDB存储）？**

快照，顾名思义可以理解为拍照一样，把整个内存数据映射到硬盘中，保存一份到硬盘，因此恢复数据起来比较快，把数据映射回去即可，不像AOF，一条条的执行操作命令。产生快照的过程：

1 .用户在配置文件了配置了类似这样的命令

```
save 900 1 // 900秒内,有1条写入,则产生快照
save 300 1000 // 如果300秒内有1000次写入,则产生快照
save 60 10000 // 如果60秒内有10000次写入,则产生快照
```

\(这3个选项都屏蔽,则rdb禁用\)

2.执行bgsave命令\(此时redis会fork一个子进程,子进程负责生成硬盘文件,父进程负责继续接受命令\).

或执行save命令\(和bgsave命令不同,发送save命令后,到系统创建快照完成之前系统不会再接收新的命令,换句话说save命令会阻塞后面的命令,而bgsave不会\)

3.用户发送shutdown,系统会先执行save命令阻塞客户端,然后关闭服务器  
4.当有主从架构时,从服务器向主服务器发送sync命令来执行复制操作时,当时只要主服务器没有进行bgsave操作,那么主服务器就会执行bgsave操作。

**17.Dump快照的机制**

1\). Redis先fork子进程。

2\). 子进程将快照数据写入到临时RDB文件中。

3\). 当子进程完成数据写入操作后，再用临时文件替换老的文件。

**18**.**Redis 集群方案什么情况下会导致整个集群不可用？**

1\).有 A，B，C 三个节点的集群,在没有复制模型的情况下\(没有slave情下况\),如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。

2\).如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态

**19、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？**

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略.

淘汰策略：**参考上面的14.**

**20.说说 Redis 哈希槽的概念？**

Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

**21.Redis 集群的主从复制模型是怎样的？**

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.

**22.Redis 集群会有写操作丢失吗？为什么？**

Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

**23.Redis 集群之间是如何复制的？**

异步复制

**24.Redis 集群最大节点个数是多少？**

16384 个

**25.Redis 集群如何选择数据库？**

Redis 集群目前无法做数据库选择，默认在 0 数据库。

**26.Redis 中的管道有什么用？**

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。

**27.怎么理解 Redis 事务？**

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

**28.Redis与MySQL中事务的区别**

事务命令

mysql：

```
begin      #显式地开启一个事务
commit      #提交事务，对数据库进行的所有写操作变为永久性的
rollback  #结束用户的事务，并撤销正在进行的所有未提交的写操作
```

redis支持简单的事务：

```
multi        #标记事务的开始
exec        #执行事务的commands队列
discard        #结束事务，并清除commands队列
```

roolback和discard的区别：

如果已经成功执行了2条语句，第3条语句出错。roolback后撤销前面2条语句的照成的影响；discard只是结束本次事务，前面2条语句造成的影响仍然存在。

在multi后面的语句出错可能有两种情况：

1、语法就有问题。\(这种exec时报错，所有语句都不执行\)

2、语法本身没有错，但使用对象有问题。比如zadd命令操作link对象，exec之后回执行正确的语句并跳过不适当的语句。

**29.Redis key 的过期时间和永久有效分别怎么设置**

EXPIRE 和 PERSIST 命令

**30.什么是缓存雪崩？解决方案?**

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

解决方案：

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期

3：不同的 key，设置不同的过期时间（每个key后面加一个随时间戳），让缓存失效的时间点尽量均匀

**31.什么**是**缓存击穿？**

一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。

解决方案：

在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

**32**.**使用过 Redis 做异步队列么，你是怎么用的？有什么缺点？**

般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep一会再重试。

方式一：生产者消费者模式  
使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。  
或者，不用sleep，直接用blpop指令，在没有消息的时候，它会阻塞住直到消息到来。

方式二：发布订阅者模式  
使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

缺点**：**在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。

**34**.**使用 redis 如何设计分布式锁？说一下实现思路？使用 zk 可以吗？如何实现？这两种有什么区别？**

**35.Redis的并发竞争问题如何解决?**

Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：

1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。

2.服务器角度，利用setnx实现锁。

> 注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。

**36.Redis主从模式下宕机怎么办**

**1\).slave宕机**

相对简单，slave启动后会自动同步数据，增量同步。

**2\).master宕机**

* **手动恢复**

1. 在从数据库中执行SLAVEOFNO ONE命令，断开主从关系并且将从库提升为主库继续服务；
2. 将主库重新启动后，执行SLAVEOF命令，将其设置为其他库的从库，这时数据就能更新回来

* **哨兵功能自动恢复**

通过sentinel模式启动redis后，自动监控master/slave的运行状态, 已经被集成在redis2.4+的版本中如果Master异常，则会进行Master-Slave切换，将其中一个Slave作为Master，将之前的Master作为Slave

**基本原理是**：心跳机制+投票裁决

