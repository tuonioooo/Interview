参考地址：

Redis详细教程：[https://tuonioooo.gitbooks.io/high-concurrent-cache/content/redis.html](https://tuonioooo.gitbooks.io/high-concurrent-cache/content/redis.html)

**1**.**Redis 是什么？都有哪些使用场景？**

Redis 是一个使用 C 语言开发的高速缓存数据库。

Redis 使用场景：

* 记录帖子点赞数、点击数、评论数；
* 缓存近期热帖；
* 缓存文章详情信息；
* 记录用户会话信息。

**2. Redis 有哪些功能？**

* 数据缓存功能
* 分布式锁的功能
* 支持数据持久化
* 支持事务
* 支持消息队列

**3. Redis 和 memcache 有什么区别？**

* 存储方式不同：
  memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小；Redis 有部份存在硬盘上，这样能保证数据的持久性。
* 数据支持类型：
  memcache 对数据类型支持相对简单；Redis 有复杂的数据类型。
* 使用底层模型不同：它们之间底层实现方式，以及与客户端之间通信的应用协议不一样，
  Redis 自己构建了 vm 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
* value 值大小不同：Redis 最大可以达到 512mb；memcache 只有 1mb。
* redis 的速度比 memcached 快很多 redis 的速度比 memcached 快很多.

如图所示：

![](/assets/2528523275-5ad8abd940cd7_articlex.jpg)

**4. Redis 为什么是单线程的？**

因为cpu 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且 cpu 又不会成为瓶颈，那就顺理成章地采用单线程的方案了。

关于Redis 的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求。

而且单线程并不代表就慢nginx 和 nodejs 也都是高性能单线程的代表。

**5. 什么是缓存穿透？怎么解决？**

缓存穿透：指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

解决方案：

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该 key 对应的数据 insert 了之后清理缓存。

2：对一定不存在的 key 进行过滤。可以把所有的可能存在的 key 放到一个大的 Bitmap 中，查询时通过该 bitmap 过滤。

**6. Redis 支持的数据类型有哪些？**

Redis 支持的数据类型：string（字符串）、list（列表）、hash（散列表）、set（集合）、\(Sorted set\)zset（有序集合）。

**7. Redis 支持的 Java 客户端都有哪些？**

支持的Java 客户端有 Redisson、jedis、lettuce 等。

**8. jedis 和 Redisson 有哪些区别？**

* jedis：提供了比较全面的 Redis 命令的支持。
* Redisson：实现了分布式和可扩展的 Java 数据结构，与 jedis 相比 Redisson 的功能相对简单，不支持排序、事务、管道、分区等 Redis 特性。

**9. 怎么保证缓存和数据库数据的一致性？**

* 合理设置缓存的过期时间。
* 新增、更改、删除数据库操作时同步更新
  Redis，可以使用事物机制来保证数据的一致性。

**10. Redis 持久化有几种方式？**

Redis 的持久化有两种方式，或者说有两种策略：

* RDB（Redis Database）：指定的时间间隔能对你的数据进行快照存储。
* AOF（Append Only File）：每一个收到的写命令都通过write函数追加到文件中。

> 注意：
>
> **RDB**：快照形式，定期把内存中当前时刻的数据保存到磁盘。Redis默认支持的持久化方案。速度快但是服务器断电的时候会丢失部分数据
>
> **AOF**：append only file。把所有对redis数据库操作的命令，增删改操作的命令。保存到文件中。数据库恢复时把所有的命令执行一遍即可。两种持久化方案同时开启使用AOF文件来恢复数据库.能保证数据的完整性,但是速度慢。
>
> 两者如何选择?
>
> 1. 如果redis仅仅是用来做为缓存服务器的话，我们可以不使用任何的持久化。
> 2. 一般情况下我们会将两种持久化的方式都开启。redis优先加载AOF文件来回复数据。RDB的好处是快速。
> 3. 在主从节点中，RDB作为我们的备份数据，只在salve\(从节点\)上启动，同步时间可以设置的长一点，只留\(save 900 1\)这条规则就可以了。
> 4. 开启AOF的情况下，主从同步是时候必然会带来IO的性能影响，此时我们可以调大auto-aof-rewrite-min-size的值，比如5GB。来减少IO的频率
> 5. 不开启AOF的情况下，可以节省IO的性能影响，这是主从间通过RDB持久化同步，但如果主从都挂掉，影响较大~

**11. Redis 怎么实现分布式锁？**

Redis 分布式锁其实就是在系统里面占一个“坑”，其他程序也要占“坑”的时候，占用成功了就可以继续执行，失败了就只能放弃或稍后重试。

占坑一般使用setnx\(set if not exists\)指令，只允许被一个程序占有，使用完调用 del 释放锁。

**12. Redis 分布式锁有什么缺陷？**

Redis 分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。

**13. Redis 如何做内存优化？**

尽量使用Redis 的散列表，把相关的信息放到散列表里面存储，而不是把每个字段单独存储，这样可以有效的减少内存使用。比如将 Web 系统的用户对象，应该放到散列表里面再整体存储到 Redis，而不是把用户的姓名、年龄、密码、邮箱等字段分别设置 key 进行存储。

**14. Redis 淘汰策略有哪些？**

* volatile-lru：从已设置过期时间的数据集（server. db\[i\]. expires）中挑选最近最少使用的数据淘汰。
* volatile-ttl：从已设置过期时间的数据集（server. db\[i\]. expires）中挑选将要过期的数据淘汰。
* volatile-random：从已设置过期时间的数据集（server. db\[i\]. expires）中任意选择数据淘汰。
* allkeys-lru：从数据集（server. db\[i\]. dict）中挑选最近最少使用的数据淘汰。
* allkeys-random：从数据集（server. db\[i\]. dict）中任意选择数据淘汰。
* no-enviction（驱逐）：禁止驱逐数据。

**15. Redis 常见的性能问题有哪些？该如何解决？**

* 主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。
* Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。
* 尽量避免在压力很大的主库上增加从库
* 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次

**16.Redis如何进行快照存储（如何进行RDB存储）？**

快照，顾名思义可以理解为拍照一样，把整个内存数据映射到硬盘中，保存一份到硬盘，因此恢复数据起来比较快，把数据映射回去即可，不像AOF，一条条的执行操作命令。产生快照的过程：

1 .用户在配置文件了配置了类似这样的命令

```
save 900 1 // 900秒内,有1条写入,则产生快照
save 300 1000 // 如果300秒内有1000次写入,则产生快照
save 60 10000 // 如果60秒内有10000次写入,则产生快照
```

\(这3个选项都屏蔽,则rdb禁用\)

2.执行bgsave命令\(此时redis会fork一个子进程,子进程负责生成硬盘文件,父进程负责继续接受命令\).

或执行save命令\(和bgsave命令不同,发送save命令后,到系统创建快照完成之前系统不会再接收新的命令,换句话说save命令会阻塞后面的命令,而bgsave不会\)

3.用户发送shutdown,系统会先执行save命令阻塞客户端,然后关闭服务器  
4.当有主从架构时,从服务器向主服务器发送sync命令来执行复制操作时,当时只要主服务器没有进行bgsave操作,那么主服务器就会执行bgsave操作。

**17.Dump快照的机制**

1\). Redis先fork子进程。

2\). 子进程将快照数据写入到临时RDB文件中。

3\). 当子进程完成数据写入操作后，再用临时文件替换老的文件。

**18**.**Redis 集群方案什么情况下会导致整个集群不可用？**

1\).有 A，B，C 三个节点的集群,在没有复制模型的情况下\(没有slave情下况\),如果节点 B 失败了，那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。

2\).如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态

**19、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？**

redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略.

淘汰策略：**参考上面的14.**

**20.说说 Redis 哈希槽的概念？**

Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。

**21.Redis 集群的主从复制模型是怎样的？**

为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.

**22.Redis 集群会有写操作丢失吗？为什么？**

Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

**23.Redis 集群之间是如何复制的？**

异步复制

**24.Redis 集群最大节点个数是多少？**

16384 个

**25.Redis 集群如何选择数据库？**

Redis 集群目前无法做数据库选择，默认在 0 数据库。

**26.Redis 中的管道有什么用？**

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。

**27.怎么理解 Redis 事务？**

事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行，事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

**28.Redis与MySQL中事务的区别**

事务命令

mysql：

```
begin      #显式地开启一个事务
commit      #提交事务，对数据库进行的所有写操作变为永久性的
rollback  #结束用户的事务，并撤销正在进行的所有未提交的写操作
```

redis支持简单的事务：

```
multi        #标记事务的开始
exec        #执行事务的commands队列
discard        #结束事务，并清除commands队列
```

roolback和discard的区别：

如果已经成功执行了2条语句，第3条语句出错。roolback后撤销前面2条语句的照成的影响；discard只是结束本次事务，前面2条语句造成的影响仍然存在。

在multi后面的语句出错可能有两种情况：

1、语法就有问题。\(这种exec时报错，所有语句都不执行\)

2、语法本身没有错，但使用对象有问题。比如zadd命令操作link对象，exec之后回执行正确的语句并跳过不适当的语句。

**29.Redis key 的过期时间和永久有效分别怎么设置**

EXPIRE 和 PERSIST 命令

**30.什么是缓存雪崩？解决方案?**

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

解决方案：

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个 key 只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1 为原始缓存，A2 为拷贝缓存，A1 失效时，可以访问 A2，A1 缓存失效时间设置为短期，A2 设置为长期

3：不同的 key，设置不同的过期时间（每个key后面加一个随时间戳），让缓存失效的时间点尽量均匀

**31.什么**是**缓存击穿？**

一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。

解决方案：

在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。

**32**.**使用过 Redis 做异步队列么，你是怎么用的？有什么缺点？**

般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep一会再重试。

方式一：生产者消费者模式  
使用list结构作为队列，rpush生产消息，lpop消费消息，当lpop没有消息的时候，要适当sleep一会再重试。  
或者，不用sleep，直接用blpop指令，在没有消息的时候，它会阻塞住直到消息到来。

方式二：发布订阅者模式  
使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

缺点**：**在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。

**34**.

**35.Redis的并发竞争问题如何解决?**

Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。对此有2种解决方法：

1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。

2.服务器角度，利用setnx实现锁。

> 注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。

**36.Redis主从模式下宕机怎么办**

**1\).slave宕机**

相对简单，slave启动后会自动同步数据，增量同步。

**2\).master宕机**

* **手动恢复**

在从数据库中执行SLAVEOFNO ONE命令，断开主从关系并且将从库提升为主库继续服务；

将主库重新启动后，执行SLAVEOF命令，将其设置为其他库的从库，这时数据就能更新回来

* **哨兵功能自动恢复**

通过sentinel模式启动redis后，自动监控master/slave的运行状态, 已经被集成在redis2.4+的版本中如果Master异常，则会进行Master-Slave切换，将其中一个Slave作为Master，将之前的Master作为Slave

**基本原理是**：心跳机制+投票裁决

**37.缓存预热**

缓存预热就是系统上线后，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！

**缓存预热解决方案**：

1. 直接写个缓存刷新页面，上线时手工操作下；
2. 数据量不大，可以在项目启动的时候自动进行加载；
3. 定时刷新缓存；

**38.缓存更新**

我们知道通过expire来设置key 的过期时间,那么对过期的数据怎么处理呢?除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：

1. 定时去清理过期的缓存；
2. 当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。

两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。

**39.缓存降级**

当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。 **降级的最终目的**是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：

1. 一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
2. 警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；
3. 错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；
4. 严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。

**40.缓存热点key**

使用缓存 + 过期时间的策略既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：

1. 当前 key 是一个热点 key\( 可能对应应用的热卖商品、热点新闻、热点评论等），并发量非常大。
2. 重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的 SQL、多次 IO、多个依赖等。

于是就会出现一个致命问题：在缓存失效的瞬间，有大量线程来构建缓存（见下图），造成后端负载加大，甚至可能会让系统崩溃　。

![](/assets/d65per0hcd.jpeg)

四种解决方案（注释：第１，２种方法来自Ｔｉｍ　Ｙａｎｇ博客）

我们的目标是：尽量少的线程构建缓存（甚至是一个）　＋　数据一致性　＋　较少的潜在危险，下面会介绍四种方法来解决这个问题：

（1）使用互斥锁（ｍｕｔｅｘ　ｋｅｙ）：　这种解决方案思路比较简单，就是只让一个线程构建缓存，其他线程等待构建缓存的线程执行完，重新从缓存获取数据就可以了

**41.是否使用过Redis集群，集群的原理是什么？**

Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。 Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

**42.主从复制的原理**

无论是初次连接还是重新连接， 当建立一个从服务器时， 从服务器都将向主服务器发送一个 [SYNC](http://redis.readthedocs.org/cn/latest/server/sync.html#sync) 命令。

接到 [SYNC](http://redis.readthedocs.org/cn/latest/server/sync.html#sync) 命令的主服务器将开始执行 [BGSAVE](http://redis.readthedocs.org/cn/latest/server/bgsave.html#bgsave) ， 并在保存操作执行期间， 将所有新执行的写入命令都保存到一个缓冲区里面。

当 [BGSAVE](http://redis.readthedocs.org/cn/latest/server/bgsave.html#bgsave) 执行完毕后， 主服务器将执行保存操作所得的 .rdb 文件发送给从服务器， 从服务器接收这个 .rdb 文件， 并将文件中的数据载入到内存中。

之后主服务器会以 Redis 命令协议的格式， 将写命令缓冲区中积累的所有内容都发送给从服务器。

你可以通过 telnet 命令来亲自验证这个同步过程： 首先连上一个正在处理命令请求的 Redis 服务器， 然后向它发送 [SYNC](http://redis.readthedocs.org/cn/latest/server/sync.html#sync) 命令， 过一阵子， 你将看到 telnet 会话（session）接收到服务器发来的大段数据（.rdb 文件）， 之后还会看到， 所有在服务器执行过的写命令， 都会重新发送到 telnet 会话来。

即使有多个从服务器同时向主服务器发送 [SYNC](http://redis.readthedocs.org/cn/latest/server/sync.html#sync) ， 主服务器也只需执行一次 [BGSAVE](http://redis.readthedocs.org/cn/latest/server/bgsave.html#bgsave) 命令， 就可以处理所有这些从服务器的同步请求。

从服务器可以在主从服务器之间的连接断开时进行自动重连， 在 Redis 2.8 版本之前， 断线之后重连的从服务器总要执行一次完整重同步（full resynchronization）操作， 但是从 Redis 2.8 版本开始， 从服务器可以根据主服务器的情况来选择执行完整重同步还是部分重同步（partial resynchronization）。

**43.Redis的数据备份**

在Redis中我们可以通过copy的方式在线备份正在运行的Redis数据文件。这是因为RDB文件一旦被生成之后就不会再被修改。Redis每次都是将最新的数据dump到一个临时文件中，之后在利用rename函数原子性的将临时文件改名为原有的数据文件名。因此我们可以说，在任意时刻copy数据文件都是安全的和一致的。鉴于此，我们就可以通过创建cron job的方式定时备份Redis的数据文件，并将备份文件copy到安全的磁盘介质中。

**44.AOF文件配置以及如何修复AOF文件**

上面已经多次讲过，RDB的快照定时dump机制无法保证很好的数据持久性。如果我们的应用确实非常关注此点，我们可以考虑使用Redis中的AOF机制。对于Redis服务器而言，其缺省的机制是RDB，如果需要使用AOF，则需要修改配置文件中的以下条目：

将_appendonly no_改为_appendonly yes_

从现在起，Redis在每一次接收到数据修改的命令之后，都会将其追加到AOF文件中。在Redis下一次重新启动时，需要加载AOF文件中的信息来构建最新的数据到内存中。

AOF配置：

```
appendfsync always     #每次有数据修改发生时都会写入AOF文件。
appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。
appendfsync no         #从不同步。高效但是数据不会被持久化。
```

修复AOF文件方法：

```
1). 将现有已经坏损的AOF文件额外拷贝出来一份。
2). 执行"redis-check-aof --fix <filename>"命令来修复坏损的AOF文件。
3). 用修复后的AOF文件重新启动Redis服务器。
```



